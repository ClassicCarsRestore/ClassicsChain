// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_invitation.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const claimUserInvitation = `-- name: ClaimUserInvitation :exec
UPDATE user_invitations
SET claimed_at = NOW()
WHERE token = $1
`

func (q *Queries) ClaimUserInvitation(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, claimUserInvitation, token)
	return err
}

const createUserInvitation = `-- name: CreateUserInvitation :one
INSERT INTO user_invitations (
    email,
    name,
    token,
    token_expires_at,
    invitation_type,
    entity_id,
    entity_role
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, email, name, token, token_expires_at, entity_id, invitation_type, entity_role, invited_at, claimed_at
`

type CreateUserInvitationParams struct {
	Email          string
	Name           *string
	Token          string
	TokenExpiresAt pgtype.Timestamp
	InvitationType string
	EntityID       *uuid.UUID
	EntityRole     *string
}

func (q *Queries) CreateUserInvitation(ctx context.Context, arg CreateUserInvitationParams) (UserInvitation, error) {
	row := q.db.QueryRow(ctx, createUserInvitation,
		arg.Email,
		arg.Name,
		arg.Token,
		arg.TokenExpiresAt,
		arg.InvitationType,
		arg.EntityID,
		arg.EntityRole,
	)
	var i UserInvitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Token,
		&i.TokenExpiresAt,
		&i.EntityID,
		&i.InvitationType,
		&i.EntityRole,
		&i.InvitedAt,
		&i.ClaimedAt,
	)
	return i, err
}

const deleteUserInvitation = `-- name: DeleteUserInvitation :exec
DELETE FROM user_invitations
WHERE id = $1
`

func (q *Queries) DeleteUserInvitation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserInvitation, id)
	return err
}

const getPendingUserInvitationsByEmail = `-- name: GetPendingUserInvitationsByEmail :many
SELECT id, email, name, token, token_expires_at, entity_id, invitation_type, entity_role, invited_at, claimed_at
FROM user_invitations
WHERE email = $1
  AND claimed_at IS NULL
ORDER BY invited_at ASC
`

func (q *Queries) GetPendingUserInvitationsByEmail(ctx context.Context, email string) ([]UserInvitation, error) {
	rows, err := q.db.Query(ctx, getPendingUserInvitationsByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserInvitation{}
	for rows.Next() {
		var i UserInvitation
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Token,
			&i.TokenExpiresAt,
			&i.EntityID,
			&i.InvitationType,
			&i.EntityRole,
			&i.InvitedAt,
			&i.ClaimedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserInvitationByID = `-- name: GetUserInvitationByID :one
SELECT id, email, name, token, token_expires_at, entity_id, invitation_type, entity_role, invited_at, claimed_at
FROM user_invitations
WHERE id = $1
`

func (q *Queries) GetUserInvitationByID(ctx context.Context, id uuid.UUID) (UserInvitation, error) {
	row := q.db.QueryRow(ctx, getUserInvitationByID, id)
	var i UserInvitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Token,
		&i.TokenExpiresAt,
		&i.EntityID,
		&i.InvitationType,
		&i.EntityRole,
		&i.InvitedAt,
		&i.ClaimedAt,
	)
	return i, err
}

const getUserInvitationByToken = `-- name: GetUserInvitationByToken :one
SELECT id, email, name, token, token_expires_at, entity_id, invitation_type, entity_role, invited_at, claimed_at
FROM user_invitations
WHERE token = $1
  AND claimed_at IS NULL
  AND token_expires_at > NOW()
`

func (q *Queries) GetUserInvitationByToken(ctx context.Context, token string) (UserInvitation, error) {
	row := q.db.QueryRow(ctx, getUserInvitationByToken, token)
	var i UserInvitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Token,
		&i.TokenExpiresAt,
		&i.EntityID,
		&i.InvitationType,
		&i.EntityRole,
		&i.InvitedAt,
		&i.ClaimedAt,
	)
	return i, err
}
