// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invitation.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const claimInvitation = `-- name: ClaimInvitation :one
UPDATE vehicle_invitations
SET claimed_at = NOW()
WHERE id = $1
RETURNING id, vehicle_id, email, invited_at, claimed_at
`

type ClaimInvitationRow struct {
	ID        uuid.UUID
	VehicleID uuid.UUID
	Email     string
	InvitedAt pgtype.Timestamp
	ClaimedAt pgtype.Timestamp
}

func (q *Queries) ClaimInvitation(ctx context.Context, id uuid.UUID) (ClaimInvitationRow, error) {
	row := q.db.QueryRow(ctx, claimInvitation, id)
	var i ClaimInvitationRow
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.Email,
		&i.InvitedAt,
		&i.ClaimedAt,
	)
	return i, err
}

const claimInvitationsByEmail = `-- name: ClaimInvitationsByEmail :exec
UPDATE vehicle_invitations
SET claimed_at = NOW()
WHERE email = $1 AND claimed_at IS NULL
`

func (q *Queries) ClaimInvitationsByEmail(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, claimInvitationsByEmail, email)
	return err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO vehicle_invitations (vehicle_id, email, token, token_expires_at)
VALUES ($1, $2, $3, $4)
RETURNING id, vehicle_id, email, token, token_expires_at, invited_at, claimed_at
`

type CreateInvitationParams struct {
	VehicleID      uuid.UUID
	Email          string
	Token          *string
	TokenExpiresAt pgtype.Timestamp
}

type CreateInvitationRow struct {
	ID             uuid.UUID
	VehicleID      uuid.UUID
	Email          string
	Token          *string
	TokenExpiresAt pgtype.Timestamp
	InvitedAt      pgtype.Timestamp
	ClaimedAt      pgtype.Timestamp
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (CreateInvitationRow, error) {
	row := q.db.QueryRow(ctx, createInvitation,
		arg.VehicleID,
		arg.Email,
		arg.Token,
		arg.TokenExpiresAt,
	)
	var i CreateInvitationRow
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.Email,
		&i.Token,
		&i.TokenExpiresAt,
		&i.InvitedAt,
		&i.ClaimedAt,
	)
	return i, err
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM vehicle_invitations
WHERE id = $1
`

func (q *Queries) DeleteInvitation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInvitation, id)
	return err
}

const getAllPendingInvitations = `-- name: GetAllPendingInvitations :many
SELECT id, vehicle_id, email, token, token_expires_at, invited_at, claimed_at
FROM vehicle_invitations
WHERE claimed_at IS NULL
ORDER BY invited_at ASC
`

type GetAllPendingInvitationsRow struct {
	ID             uuid.UUID
	VehicleID      uuid.UUID
	Email          string
	Token          *string
	TokenExpiresAt pgtype.Timestamp
	InvitedAt      pgtype.Timestamp
	ClaimedAt      pgtype.Timestamp
}

func (q *Queries) GetAllPendingInvitations(ctx context.Context) ([]GetAllPendingInvitationsRow, error) {
	rows, err := q.db.Query(ctx, getAllPendingInvitations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPendingInvitationsRow{}
	for rows.Next() {
		var i GetAllPendingInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.Email,
			&i.Token,
			&i.TokenExpiresAt,
			&i.InvitedAt,
			&i.ClaimedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationByID = `-- name: GetInvitationByID :one
SELECT id, vehicle_id, email, invited_at, claimed_at
FROM vehicle_invitations
WHERE id = $1
`

type GetInvitationByIDRow struct {
	ID        uuid.UUID
	VehicleID uuid.UUID
	Email     string
	InvitedAt pgtype.Timestamp
	ClaimedAt pgtype.Timestamp
}

func (q *Queries) GetInvitationByID(ctx context.Context, id uuid.UUID) (GetInvitationByIDRow, error) {
	row := q.db.QueryRow(ctx, getInvitationByID, id)
	var i GetInvitationByIDRow
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.Email,
		&i.InvitedAt,
		&i.ClaimedAt,
	)
	return i, err
}

const getInvitationByToken = `-- name: GetInvitationByToken :one
SELECT id, vehicle_id, email, token, token_expires_at, invited_at, claimed_at
FROM vehicle_invitations
WHERE token = $1 AND claimed_at IS NULL AND token_expires_at > NOW()
`

type GetInvitationByTokenRow struct {
	ID             uuid.UUID
	VehicleID      uuid.UUID
	Email          string
	Token          *string
	TokenExpiresAt pgtype.Timestamp
	InvitedAt      pgtype.Timestamp
	ClaimedAt      pgtype.Timestamp
}

func (q *Queries) GetInvitationByToken(ctx context.Context, token *string) (GetInvitationByTokenRow, error) {
	row := q.db.QueryRow(ctx, getInvitationByToken, token)
	var i GetInvitationByTokenRow
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.Email,
		&i.Token,
		&i.TokenExpiresAt,
		&i.InvitedAt,
		&i.ClaimedAt,
	)
	return i, err
}

const getInvitationsByEmailAndVehicle = `-- name: GetInvitationsByEmailAndVehicle :many
SELECT id, vehicle_id, email, invited_at, claimed_at
FROM vehicle_invitations
WHERE email = $1 AND vehicle_id = ANY($2::uuid[])
ORDER BY vehicle_id, invited_at ASC
`

type GetInvitationsByEmailAndVehicleParams struct {
	Email   string
	Column2 []uuid.UUID
}

type GetInvitationsByEmailAndVehicleRow struct {
	ID        uuid.UUID
	VehicleID uuid.UUID
	Email     string
	InvitedAt pgtype.Timestamp
	ClaimedAt pgtype.Timestamp
}

func (q *Queries) GetInvitationsByEmailAndVehicle(ctx context.Context, arg GetInvitationsByEmailAndVehicleParams) ([]GetInvitationsByEmailAndVehicleRow, error) {
	rows, err := q.db.Query(ctx, getInvitationsByEmailAndVehicle, arg.Email, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvitationsByEmailAndVehicleRow{}
	for rows.Next() {
		var i GetInvitationsByEmailAndVehicleRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.Email,
			&i.InvitedAt,
			&i.ClaimedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingInvitationsByEmail = `-- name: GetPendingInvitationsByEmail :many
SELECT id, vehicle_id, email, token, token_expires_at, invited_at, claimed_at
FROM vehicle_invitations
WHERE email = $1 AND claimed_at IS NULL
ORDER BY invited_at ASC
`

type GetPendingInvitationsByEmailRow struct {
	ID             uuid.UUID
	VehicleID      uuid.UUID
	Email          string
	Token          *string
	TokenExpiresAt pgtype.Timestamp
	InvitedAt      pgtype.Timestamp
	ClaimedAt      pgtype.Timestamp
}

func (q *Queries) GetPendingInvitationsByEmail(ctx context.Context, email string) ([]GetPendingInvitationsByEmailRow, error) {
	rows, err := q.db.Query(ctx, getPendingInvitationsByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingInvitationsByEmailRow{}
	for rows.Next() {
		var i GetPendingInvitationsByEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.Email,
			&i.Token,
			&i.TokenExpiresAt,
			&i.InvitedAt,
			&i.ClaimedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
