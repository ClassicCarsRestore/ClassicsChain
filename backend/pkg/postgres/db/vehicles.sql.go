// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vehicles.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const claimVehicle = `-- name: ClaimVehicle :one
UPDATE vehicles
SET owner_id = $2, updated_at = NOW()
WHERE id = $1 AND owner_id IS NULL
RETURNING id, owner_id, chassis_number, license_plate, engine_number, transmission_number, make, model, year, color, body_type, drive_type, gear_type, suspension_type, cid, cid_source_json, cid_source_cbor_b64, blockchain_asset_id, created_at, updated_at
`

type ClaimVehicleParams struct {
	ID      uuid.UUID
	OwnerID *uuid.UUID
}

func (q *Queries) ClaimVehicle(ctx context.Context, arg ClaimVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, claimVehicle, arg.ID, arg.OwnerID)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.ChassisNumber,
		&i.LicensePlate,
		&i.EngineNumber,
		&i.TransmissionNumber,
		&i.Make,
		&i.Model,
		&i.Year,
		&i.Color,
		&i.BodyType,
		&i.DriveType,
		&i.GearType,
		&i.SuspensionType,
		&i.Cid,
		&i.CidSourceJson,
		&i.CidSourceCborB64,
		&i.BlockchainAssetID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countVehicles = `-- name: CountVehicles :one
SELECT COUNT(*) FROM vehicles
`

func (q *Queries) CountVehicles(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countVehicles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVehiclesByOwner = `-- name: CountVehiclesByOwner :one
SELECT COUNT(*) FROM vehicles
WHERE owner_id = $1
`

func (q *Queries) CountVehiclesByOwner(ctx context.Context, ownerID *uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countVehiclesByOwner, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVehicle = `-- name: CreateVehicle :one
INSERT INTO vehicles (
    license_plate,
    chassis_number,
    make,
    model,
    year,
    color,
    engine_number,
    transmission_number,
    body_type,
    drive_type,
    gear_type,
    suspension_type,
    owner_id
) VALUES (
$1,
$2,
$3,
$4,
$5,
$6,
$7,
$8,
$9,
$10,
$11,
$12,
$13
)
RETURNING id, owner_id, chassis_number, license_plate, engine_number, transmission_number, make, model, year, color, body_type, drive_type, gear_type, suspension_type, cid, cid_source_json, cid_source_cbor_b64, blockchain_asset_id, created_at, updated_at
`

type CreateVehicleParams struct {
	LicensePlate       string
	ChassisNumber      string
	Make               string
	Model              string
	Year               int32
	Color              string
	EngineNumber       string
	TransmissionNumber string
	BodyType           string
	DriveType          string
	GearType           string
	SuspensionType     string
	OwnerID            *uuid.UUID
}

func (q *Queries) CreateVehicle(ctx context.Context, arg CreateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, createVehicle,
		arg.LicensePlate,
		arg.ChassisNumber,
		arg.Make,
		arg.Model,
		arg.Year,
		arg.Color,
		arg.EngineNumber,
		arg.TransmissionNumber,
		arg.BodyType,
		arg.DriveType,
		arg.GearType,
		arg.SuspensionType,
		arg.OwnerID,
	)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.ChassisNumber,
		&i.LicensePlate,
		&i.EngineNumber,
		&i.TransmissionNumber,
		&i.Make,
		&i.Model,
		&i.Year,
		&i.Color,
		&i.BodyType,
		&i.DriveType,
		&i.GearType,
		&i.SuspensionType,
		&i.Cid,
		&i.CidSourceJson,
		&i.CidSourceCborB64,
		&i.BlockchainAssetID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVehicle = `-- name: DeleteVehicle :exec
DELETE FROM vehicles
WHERE id = $1
`

func (q *Queries) DeleteVehicle(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVehicle, id)
	return err
}

const getVehicle = `-- name: GetVehicle :one
SELECT id, owner_id, chassis_number, license_plate, engine_number, transmission_number, make, model, year, color, body_type, drive_type, gear_type, suspension_type, cid, cid_source_json, cid_source_cbor_b64, blockchain_asset_id, created_at, updated_at FROM vehicles
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetVehicle(ctx context.Context, id uuid.UUID) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicle, id)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.ChassisNumber,
		&i.LicensePlate,
		&i.EngineNumber,
		&i.TransmissionNumber,
		&i.Make,
		&i.Model,
		&i.Year,
		&i.Color,
		&i.BodyType,
		&i.DriveType,
		&i.GearType,
		&i.SuspensionType,
		&i.Cid,
		&i.CidSourceJson,
		&i.CidSourceCborB64,
		&i.BlockchainAssetID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVehicleByChassisNumber = `-- name: GetVehicleByChassisNumber :one
SELECT id, owner_id, chassis_number, license_plate, engine_number, transmission_number, make, model, year, color, body_type, drive_type, gear_type, suspension_type, cid, cid_source_json, cid_source_cbor_b64, blockchain_asset_id, created_at, updated_at FROM vehicles
WHERE chassis_number = $1 LIMIT 1
`

func (q *Queries) GetVehicleByChassisNumber(ctx context.Context, chassisNumber string) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicleByChassisNumber, chassisNumber)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.ChassisNumber,
		&i.LicensePlate,
		&i.EngineNumber,
		&i.TransmissionNumber,
		&i.Make,
		&i.Model,
		&i.Year,
		&i.Color,
		&i.BodyType,
		&i.DriveType,
		&i.GearType,
		&i.SuspensionType,
		&i.Cid,
		&i.CidSourceJson,
		&i.CidSourceCborB64,
		&i.BlockchainAssetID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVehicleByLicensePlate = `-- name: GetVehicleByLicensePlate :one
SELECT id, owner_id, chassis_number, license_plate, engine_number, transmission_number, make, model, year, color, body_type, drive_type, gear_type, suspension_type, cid, cid_source_json, cid_source_cbor_b64, blockchain_asset_id, created_at, updated_at FROM vehicles
WHERE license_plate = $1 LIMIT 1
`

func (q *Queries) GetVehicleByLicensePlate(ctx context.Context, licensePlate string) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicleByLicensePlate, licensePlate)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.ChassisNumber,
		&i.LicensePlate,
		&i.EngineNumber,
		&i.TransmissionNumber,
		&i.Make,
		&i.Model,
		&i.Year,
		&i.Color,
		&i.BodyType,
		&i.DriveType,
		&i.GearType,
		&i.SuspensionType,
		&i.Cid,
		&i.CidSourceJson,
		&i.CidSourceCborB64,
		&i.BlockchainAssetID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listVehicles = `-- name: ListVehicles :many
SELECT id, owner_id, chassis_number, license_plate, engine_number, transmission_number, make, model, year, color, body_type, drive_type, gear_type, suspension_type, cid, cid_source_json, cid_source_cbor_b64, blockchain_asset_id, created_at, updated_at FROM vehicles
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListVehiclesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListVehicles(ctx context.Context, arg ListVehiclesParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, listVehicles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vehicle{}
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.ChassisNumber,
			&i.LicensePlate,
			&i.EngineNumber,
			&i.TransmissionNumber,
			&i.Make,
			&i.Model,
			&i.Year,
			&i.Color,
			&i.BodyType,
			&i.DriveType,
			&i.GearType,
			&i.SuspensionType,
			&i.Cid,
			&i.CidSourceJson,
			&i.CidSourceCborB64,
			&i.BlockchainAssetID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVehiclesByOwner = `-- name: ListVehiclesByOwner :many
SELECT id, owner_id, chassis_number, license_plate, engine_number, transmission_number, make, model, year, color, body_type, drive_type, gear_type, suspension_type, cid, cid_source_json, cid_source_cbor_b64, blockchain_asset_id, created_at, updated_at FROM vehicles
WHERE owner_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListVehiclesByOwnerParams struct {
	OwnerID *uuid.UUID
	Limit   int32
	Offset  int32
}

func (q *Queries) ListVehiclesByOwner(ctx context.Context, arg ListVehiclesByOwnerParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, listVehiclesByOwner, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vehicle{}
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.ChassisNumber,
			&i.LicensePlate,
			&i.EngineNumber,
			&i.TransmissionNumber,
			&i.Make,
			&i.Model,
			&i.Year,
			&i.Color,
			&i.BodyType,
			&i.DriveType,
			&i.GearType,
			&i.SuspensionType,
			&i.Cid,
			&i.CidSourceJson,
			&i.CidSourceCborB64,
			&i.BlockchainAssetID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVehicle = `-- name: UpdateVehicle :one
UPDATE vehicles
SET license_plate = $2, chassis_number = $3, make = $4, model = $5,
    year = $6, color = $7, engine_number = $8, transmission_number = $9,
    body_type = $10, drive_type = $11, gear_type = $12, suspension_type = $13,
    owner_id = $14, blockchain_asset_id = $15, cid = $16, cid_source_json = $17, cid_source_cbor_b64 = $18,
    updated_at = NOW()
WHERE id = $1
RETURNING id, owner_id, chassis_number, license_plate, engine_number, transmission_number, make, model, year, color, body_type, drive_type, gear_type, suspension_type, cid, cid_source_json, cid_source_cbor_b64, blockchain_asset_id, created_at, updated_at
`

type UpdateVehicleParams struct {
	ID                 uuid.UUID
	LicensePlate       string
	ChassisNumber      string
	Make               string
	Model              string
	Year               int32
	Color              string
	EngineNumber       string
	TransmissionNumber string
	BodyType           string
	DriveType          string
	GearType           string
	SuspensionType     string
	OwnerID            *uuid.UUID
	BlockchainAssetID  string
	Cid                *string
	CidSourceJson      *string
	CidSourceCborB64   *string
}

func (q *Queries) UpdateVehicle(ctx context.Context, arg UpdateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, updateVehicle,
		arg.ID,
		arg.LicensePlate,
		arg.ChassisNumber,
		arg.Make,
		arg.Model,
		arg.Year,
		arg.Color,
		arg.EngineNumber,
		arg.TransmissionNumber,
		arg.BodyType,
		arg.DriveType,
		arg.GearType,
		arg.SuspensionType,
		arg.OwnerID,
		arg.BlockchainAssetID,
		arg.Cid,
		arg.CidSourceJson,
		arg.CidSourceCborB64,
	)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.ChassisNumber,
		&i.LicensePlate,
		&i.EngineNumber,
		&i.TransmissionNumber,
		&i.Make,
		&i.Model,
		&i.Year,
		&i.Color,
		&i.BodyType,
		&i.DriveType,
		&i.GearType,
		&i.SuspensionType,
		&i.Cid,
		&i.CidSourceJson,
		&i.CidSourceCborB64,
		&i.BlockchainAssetID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
